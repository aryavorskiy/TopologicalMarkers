var documenterSearchIndex = {"docs":
[{"location":"visual/#Visualization","page":"Visualize","title":"Visualization","text":"","category":"section"},{"location":"visual/#coord_repr","page":"Visualize","title":"Coordinate representation","text":"","category":"section"},{"location":"visual/","page":"Visualize","title":"Visualize","text":"The CoordinateRepr struct is a workaround to deal with certain ambiguity of matrix graphical representations.  We usually index its elements row-first, and print the rows in ascending order (i. e. the natural representation).  However, if you plot a heatmap for a matrix, its first index is treated as x, the second - as y,  and the Ox axis is directed upward. That's where we need this struct.","category":"page"},{"location":"visual/","page":"Visualize","title":"Visualize","text":"The constructor takes two arguments - the matrix itself and a symbol - a representation specifier,  which tells if the matrix should be treated as natural (:n or :natural) or coordinate (:c or :coord) representation.","category":"page"},{"location":"visual/","page":"Visualize","title":"Visualize","text":"Let us look at an example:","category":"page"},{"location":"visual/","page":"Visualize","title":"Visualize","text":"mat = zeros(12, 12)\nmat[1:5, 1:5] .= 1\nmat[1:10, 6:10] .= -1\nmat","category":"page"},{"location":"visual/","page":"Visualize","title":"Visualize","text":"You can see how this matrix looks when printed in a natural way. Let us look at a heatmap of both representations:","category":"page"},{"location":"visual/","page":"Visualize","title":"Visualize","text":"using TopologicalMarkers, Plots\n\np = plot(layout = (1, 2), size = (800, 300))\nheatmap!(p[1], title=\"'Natural' representation\", CoordinateRepr(mat, :n))\nheatmap!(p[2], title=\"'Coordinate' representation\", CoordinateRepr(mat, :c))","category":"page"},{"location":"visual/#Data-processing","page":"Visualize","title":"Data processing","text":"","category":"section"},{"location":"visual/","page":"Visualize","title":"Visualize","text":"Most 'raw' data like operator or current matrices require additional processing before being plotted.","category":"page"},{"location":"visual/","page":"Visualize","title":"Visualize","text":"The heatmap_data function generates a CoordinateRepr object, given a linear operator matrix. It evaluates traces of diagonal elements of the operator in the coordinate representation.","category":"page"},{"location":"visual/","page":"Visualize","title":"Visualize","text":"# c is the local Chern operator\nc = 4pi * im * P * X * (I - P) * Y * P\n\nmarker = heatmap_data(c)\nheatmap(marker, color=:viridis)","category":"page"},{"location":"visual/","page":"Visualize","title":"Visualize","text":"The quiver_data function generates data to be added to a quiver plot. The input is a matrix with currents, the output is a tuple of vectors of the same length - one contains the origin points of the arrows, the other contains the arrow vectors.","category":"page"},{"location":"visual/","page":"Visualize","title":"Visualize","text":"# j is the electric currents matrix\nj = currents(H, P)\n\nps, qs = quiver_data(j)\nquiver(ps, quiver = qs, color=:blue)","category":"page"},{"location":"visual/","page":"Visualize","title":"Visualize","text":"This function supports additional arguments - suppose you need to plot only arrows that are located in some specific domain,  currents between sites that are to far away from each other (e. g. more than 5) do not need to be displayed  and arrows shorter than 0.1 must be omitted. It is possible then to specify these parameters as follows:","category":"page"},{"location":"visual/","page":"Visualize","title":"Visualize","text":"# j is the electric currents matrix\nj = currents(H, P)\nlims = (5, 10)\n\nps, qs = quiver_data(j; threshold = 0.1, dist_threshold = 5, xlims = lims, ylims = lims)\nquiver(ps, quiver = qs, color=:blue)","category":"page"},{"location":"visual/#Automatic-plotting","page":"Visualize","title":"Automatic plotting","text":"","category":"section"},{"location":"visual/","page":"Visualize","title":"Visualize","text":"These functions may come in handy if you want to plot multiple figures simultaneously and do not want to set the layout up manually.","category":"page"},{"location":"visual/","page":"Visualize","title":"Visualize","text":"The plot_figure! function can be used to plot one figure. It has one argument - the Plot object to draw on.  You can draw a heatmap, a quiver plot or bounding lines between domains if you need to. What you have to do is pass a keyword argument:","category":"page"},{"location":"visual/","page":"Visualize","title":"Visualize","text":"hmap for heatmap\ncurrents for quiver\ndomain_mapping for boundaries","category":"page"},{"location":"visual/","page":"Visualize","title":"Visualize","text":"The xlims and ylims keywords have meaning traditional for plots. All other keyword arguments are automatically parsed and then passed to the plot function at different stages depending on the prefix of the key.","category":"page"},{"location":"visual/","page":"Visualize","title":"Visualize","text":"hmap is passed to heatmap\ncurrents is passed to quiver\nbounds is passed to boundaries","category":"page"},{"location":"visual/","page":"Visualize","title":"Visualize","text":"For example, hmapcolor = :viridis means that the argument color = :viridis will be passed to the function when plotting the heatmap. ","category":"page"},{"location":"visual/","page":"Visualize","title":"Visualize","text":"Here is an example:","category":"page"},{"location":"visual/","page":"Visualize","title":"Visualize","text":"using TopologicalMarkers, Plots","category":"page"},{"location":"visual/","page":"Visualize","title":"Visualize","text":"ms = ones(15, 15)\nms[6:10, 6:10] .= 3\nB = 0.1\n\nzs = fill(:ext, 15, 15)\nzs[6:10, 6:10] .= :isolate\ndomains = CoordinateRepr(zs)\n\nH = hamiltonian(ms, :c, field = @landau(B), domain_mapping = domains)\nP = filled_projector(H)\ncur = currents(H, P)\np = plot(title=\"State density in two-domain insulator\")\nplot_figure!(p, hmap = P, currents = cur / maximum(abs.(cur)), bounds = domains, \n    hmapcolor = :viridis, currentscolor = :blue, boundsstyle = :dashdotdot, \n    boundscolor = :red)","category":"page"},{"location":"visual/","page":"Visualize","title":"Visualize","text":"The plot_auto function generates an optimal layout for the given amount of figures and then invokes plot_figure! multiple times.","category":"page"},{"location":"visual/","page":"Visualize","title":"Visualize","text":"The arguments it takes are pairs like this:","category":"page"},{"location":"visual/","page":"Visualize","title":"Visualize","text":"title => heatmap => currents","category":"page"},{"location":"visual/","page":"Visualize","title":"Visualize","text":"Here the first and the third arguments can be omitted.","category":"page"},{"location":"visual/","page":"Visualize","title":"Visualize","text":"domain mapping can be set via the same keyword argument. Also you can create figures with cutaway views if you define cutaway viewpoints via cutaway_views or cutaway_view arguments.","category":"page"},{"location":"visual/","page":"Visualize","title":"Visualize","text":"Each cutaway viewpoint is a lattice site. For each one the function takes heatmap values for every site with the same y-coordinate and plots the heatmap values dependent on x on a separate plot. Each cutaway view is shown on the plot as a line, which will be later referred to as a splitline.","category":"page"},{"location":"visual/","page":"Visualize","title":"Visualize","text":"This function also supports keyword argument parsing. The following prefixes are supported:","category":"page"},{"location":"visual/","page":"Visualize","title":"Visualize","text":"hmap is passed to heatmap\ncurrents is passed to quiver\nbounds is passed to boundaries\nsplitline is passed to splitline\ncutaway is passed to cutaway views","category":"page"},{"location":"visual/","page":"Visualize","title":"Visualize","text":"A good example is the piece of code on the main page of this website. Let us modify it a bit - add another cutaway viewpoint, set the splitline color to brown, and cutaway view line style to :dashdot","category":"page"},{"location":"visual/","page":"Visualize","title":"Visualize","text":"m_lattice = ones(25, 25)\nm_lattice[11:15, 11:15] .= -1\nH = hamiltonian(m_lattice, :c)\nP = filled_projector(H)\nX, Y = coord_operators()\nch = -4π * im * P * X * P * Y * P\n\nB = 0.01\nHb = hamiltonian(m_lattice, :c, field = @landau(B))\nPb = filled_projector(Hb)\nstr = (Pb - P) / B\n\nplot_auto(\"LCM\" => ch, \"Streda\" => str, domain_mapping = CoordinateRepr(m_lattice), \n    plot_size = (800, 600), hmapclims = (-1.5, 1.5), currentscolor = :yellow, \n    cutaway_view = (13, 13), splitlinecolor = :brown, cutawaystyle = :dashdot)","category":"page"},{"location":"operators/#Linear-operators","page":"Linear operators","title":"Linear operators","text":"","category":"section"},{"location":"operators/#Hamiltonian-generation","page":"Linear operators","title":"Hamiltonian generation","text":"","category":"section"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"info: Ambiguous coordinate representation\nTrying to map lattice sites to some values (for example, value of the m parameter) can be somewhat ambiguous.Usually the first index of the matrix stands for the row number and the second one for the column number. And when you write out the matrix values, row number 1 is on the upper side.However, if we treat the first index as the x-coordinate and the second one as the y-coordinate, the placement of the lattice values on the coordinate plane will change.To deal with this ambiguity, in all places where sites are mapped to values, use the CoordinateRepr struct. See Coordinate Representation section for more detail.","category":"page"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"The hamiltonian function can be used to generate a Chern insulator hamiltonian using the following formula:","category":"page"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"hatH = \nsum_i m_i c^dagger_i sigma_z c_i + \nsum_x-links c^dagger_i fracsigma_z - i sigma_x2 c_j + \nsum_y-links c^dagger_i fracsigma_z - i sigma_y2 c_j + \nh c","category":"page"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"The only essential parameter is m_lattice - it is a CoordinateRepr that defines the m parameter for each site. There is an alternative way to set the m_lattice - with two arguments, a Matrix and a Symbol representation specifier.","category":"page"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"Here is an example of both usages:","category":"page"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"using TopologicalMarkers","category":"page"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"m_lattice = ones(15, 15)\nm_lattice[6:10, 7:11] .= -1\nm_repr = CoordinateRepr(m_lattice, :n)\nH1 = hamiltonian(m_repr)\nH2 = hamiltonian(m_lattice, :n)\n\nH1 == H2 # These are equal ways to specify the m_lattice parameter","category":"page"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"There is an ability to isolate some sites from other ones. To do that, a domain_mapping matrix is required.  It is a CoordinateRepr{Symbol} object, which maps lattice sites to symbols, where different symbols mean different domains,  and hoppings between sites in different domains are set to zero. You can define the mapping in the hamiltonian function call, or apply it to an existing hamiltonian matrix using the domains! function:","category":"page"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"m_lattice = ones(15, 15)\n\nmapping = CoordinateRepr(fill(:domain1, 15, 15))\nmapping[6:10, 6:10] .= :domain2\n\nH1 = hamiltonian(m_lattice, :n, domain_mapping = mapping)\nH2 = hamiltonian(m_lattice, :n)\ndomains!(H2, mapping)\n\nH1 == H2 # These are equal ways to specify the domain mapping","category":"page"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"You also can apply some magnetic field to the Chern insulator.  This can be done by passing a function that takes the position vector and returns the gauge vector potential. You can write your own function  use one of the magnetic field macros defined: ","category":"page"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"@landau for Landau gauge field\n@symm for symmetric gauge field\n@flux for flux quantum","category":"page"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"You can define the field in the hamiltonian function or apply it to an existing hamiltonian matrix using the field! function:","category":"page"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"m_lattice = ones(15, 15)\nB = 0.1\n\nH0 = hamiltonian(m_lattice, :n, field = (r -> [0, r[1] * B, 0]))\nH1 = hamiltonian(m_lattice, :n, field = @landau(B))\nH2 = hamiltonian(m_lattice, :n)\nfield!(H2, @landau(B))\n\nH0 == H1 == H2 # These are equal ways to specify the field","category":"page"},{"location":"operators/#Density-and-coordinate-operators","page":"Linear operators","title":"Density and coordinate operators","text":"","category":"section"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"To calculate a density matrix for zero temperature, you can use the filled_projector function.  It accepts the hamiltonian matrix and returns a density matrix. You can also specify the Fermi level (which is zero by default).","category":"page"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"You can also generate the coordinate operators using the coord_operators function.  It takes an optional parameter symm which defines if the operators are defined symmetrically  (i. e. the point with (0, 0) coordinates is in the center of the lattice) or not  (i. e. the point with (0, 0) coordinates is in the bottom-left angle of the lattice).","category":"page"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"Here is an example of usage of both functions to calculate the local Chern marker:","category":"page"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"using Plots, LinearAlgebra\n\nm_lattice = ones(15, 15)\nm_lattice[6:10, 7:11] .= -1\nH = hamiltonian(m_lattice, :n)\n\nP = filled_projector(H)\nX, Y = coord_operators()\nc = 4pi * im * P * X * (I - P) * Y * P\n\nheatmap(heatmap_data(c), color = :viridis)","category":"page"},{"location":"operators/#Electric-current","page":"Linear operators","title":"Electric current","text":"","category":"section"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"You can calculate electric currents using the currents function.  It accepts the hamiltonian and the density matrix to produce a matrix with currents. Here is an example of electric currents in a magnetic field:","category":"page"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"using Plots\n\nB = 0.1\nH = hamiltonian(ones(15, 15), :n, field = @symm(B))\nP = filled_projector(H)\nps, qs = quiver_data(currents(H, P) * 10 / B)\nquiver(ps, quiver = qs)","category":"page"},{"location":"operators/#Bianca-Resta-currents","page":"Linear operators","title":"Bianca-Resta currents","text":"","category":"section"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"There are several ways to calculate currents of the local Chern marker.  For example, if we define it using the Bianca-Resta formula c(r) = 4pi i langle r  PXQYP  r rangle,  we can define the current J(r r) as some formula that complies the following rules:","category":"page"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"$","category":"page"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"\\begin{cases}     dt c(r) = \\sum{r'} J(r, r') \\\n    J(r, r') = - J(r', r) \\end{cases}, \\hspace{0.5cm} d_t c(r) = 4\\pi i \\langle r | i[H, PXQYP] | r \\rangle = 4\\pi i \\langle r | i([H, P]XQYP + PX[H, Q]YP + PXQY[H, P]) | r \\rangle $","category":"page"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"Let us call them Bianca-Resta currents.","category":"page"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"There are four formulas like that in this package. Each is a macro that takes matrices of the hamiltonian, the density and coordinate operators to generate a function that calculates the current between two sites (given their indices as parameters).","category":"page"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"The difference between them is that some of them are translationally invariant - if we shift the coordinate operators (e. g. redefine hatX as hatX + X_0), the values of currents will not change. Also some of them are stable - all currents are equal to zero if P is a density matrix of a stationary state of hamiltonian hatH that does not depend on time.","category":"page"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"These traits of macros in this package are in the following table:","category":"page"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"Macro Translational invariance Stability\nJ_b No No\nJ_tr Yes No\nJ_eq No Yes\nJ_treq Yes Yes","category":"page"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"To find out more about Bianca-Resta currents, check out this section.","category":"page"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"Each one takes  and returns a function that calculates a current given indices of 2 sites.","category":"page"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"To generate a matrix with currents, use the @currents macro.","category":"page"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"Here is an example animation of LCM behavior under after hamiltonian quench","category":"page"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"using Plots\n\nH1 = hamiltonian(ones(15, 15), :c)\nH2 = hamiltonian(ones(15, 15) * 3, :c)\n\nh(t) = H2\nP0 = filled_projector(H1)\nX, Y = coord_operators()\na = Animation()\n@evolution [\n    :ham => h => H,\n    P0 => h => P\n] for t in 0:0.1:3\n    c = -4pi * im * P * X * P * Y * P\n    cur = @currents @J_treq H P X Y\n    plot_auto(\"LCM currents\" => c => cur / 5, hmapclims = (-4, 1))\n    frame(a)\nend\n\ngif(a, \"example_animation.gif\", fps = 10)","category":"page"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"warning: Warning\nYou may get an error entitled as Please specify lattice size explicitly while running one of these functions.  This is caused by the fact that all these function require an additional argument, the lattice size,  but by default they use the lattice size for the last hamiltonian generated.It is quite unlikely that you encounter this error, but if you did, you can set the lattice size manually by using this function:TopologicalMarkers._set_lattice_size!(needed_lattice_size)This function accepts two integers or a tuple of two integers as arguments.Note that if no hamiltonian was generated since module import, you will definitely get this error if you try to evaluate some other operator. Do not do it. Please.","category":"page"},{"location":"operators/#Streda-currents","page":"Linear operators","title":"Streda currents","text":"","category":"section"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"Another way to calculate the LCM currents is the Streda formula. ","category":"page"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"This formula defines the LCM as the linear response of the density to the adiabatic field application: c(r) = fracdelta P(r)delta B. Such approach allows to evaluate currents of LCM quite easily - it is simply the linear response of the electric currents to the magnetic field:  J_streda(r r) = fracdelta J(r r)delta B.","category":"page"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"Note that unlike Bianca-Resta currents, these currents are localized - the current between non-adjacent sites is always zero.","category":"page"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"These currents can be evaluated as follows:","category":"page"},{"location":"operators/","page":"Linear operators","title":"Linear operators","text":"τ = 100\ntime_domain = 0:0.5:2τ\n\nTopologicalMarkers._set_lattice_size!(22, 21)\nX, Y = coord_operators()\n\nm0 = fill(-3, 22, 21)\nm0[6:12, 7:13] .= -1\n\nm1 = fill(-3, 22, 21)\nm1[7:13, 7:13] .= -1\n\nh(t) = hamiltonian(m0 + (m1 - m0) * min(1, t/τ), :c)\n\nB = 1e-6\nfunction hb(t)\n    local H = h(t)\n    field!(H, @landau(B))\n    return H\nend\n\nP0 = h(0) |> filled_projector\nP0b = hb(0) |> filled_projector\n\na = Animation()\n@evolution [\n    :ham => h => H,\n    :ham => hb => Hb,\n    P0 => h => P,\n    P0b => hb => Pb,\n] for t in time_domain\n    cur = currents(H, P)\n    curb = currents(Hb, Pb)\n    plot_auto(\"Streda currents\" => (Pb - P) / B => (curb - cur) / B, plot_title = \"Time: $t\")\n    frame(a)\nend\n\ngif(a, \"streda.gif\", fps=20)","category":"page"},{"location":"scope/#TopologicalMarkers.jl","page":"Library","title":"TopologicalMarkers.jl","text":"","category":"section"},{"location":"scope/","page":"Library","title":"Library","text":"Modules = [TopologicalMarkers]","category":"page"},{"location":"scope/#Hamiltonian-matrix","page":"Library","title":"Hamiltonian matrix","text":"","category":"section"},{"location":"scope/","page":"Library","title":"Library","text":"hamiltonian\nfield!\ndomains!\n@landau\n@symm\n@flux","category":"page"},{"location":"scope/#TopologicalMarkers.hamiltonian","page":"Library","title":"TopologicalMarkers.hamiltonian","text":"hamiltonian{T}(m_repr; <keyword arguments>)\nhamiltonian{T}(m_lattice, repr_spec; <keyword arguments>)\n\nGenerates a Hamiltonian operator for a Chern insulator using the following formula\n\nhatH =\nsum_i m_i c^dagger_i sigma_z c_i +\nsum_x-links c^dagger_i fracsigma_z - i sigma_x2 c_j +\nsum_y-links c^dagger_i fracsigma_z - i sigma_y2 c_j +\nh c\n\nArguments\n\nm_repr: The value of m on different sites, in CoordinateRepr format\n\nAlternatively, pass a matrix and a representation specifier (see CoordinateRepr for more information)\n\nKeyword arguments\n\npbc: Periodic boundary conditions. A Tuple{Bool, Bool}, each element sets boundary conditions for the horizontal and vertical edge respectively. Default is (false, false)\ndomains: A matrix with elements of arbitrary type, which maps sites to isolated domains. The hopping members between different domains are erased. There are no isolated domains by default\nfield: A function/lambda that takes two coordinates and returns the vector potential of the magnetic field. Used to calculate phase factors on hoppings. There is no magnetic field by default\n\n\n\n\n\n","category":"function"},{"location":"scope/#TopologicalMarkers.field!","page":"Library","title":"TopologicalMarkers.field!","text":"field!(H, A[, lattice_size]; intervals = 10)\n\nApplies magnetic field to specified hamiltonian. In other words, all hoppings get multiplied on a specific phase factor that can be calculated using Peierls substitution:\n\nvarphi_ij = 2pi int_i^j A(r) cdot dr\n\nThis integral is calculated explicitly for every hopping, using the A function.\n\nArguments\n\nH: the hamiltonian matrix\nA: a function that takes a Vector representing a point and returns a Vector representing the vector potential in that point\nlattice_size: the size of the lattice the hamiltonian is defined for. If not provided, this function will use the value for the hamiltonian matrix that was created last\n\nKeyword arguments\n\nintervals: the number of intervals to use when calculating the Peierls substitution phase factor\n\n\n\n\n\n","category":"function"},{"location":"scope/#TopologicalMarkers.domains!","page":"Library","title":"TopologicalMarkers.domains!","text":"domains!(H, domain_mapping, repr_spec)\ndomains!(H, domain_mapping_repr)\n\nDivides the Chern insulator hamiltonian into several unconnected domains. The hoppings between these domains are erased.\n\nArguments\n\nH: the hamiltonian matrix\ndomain_mapping_repr: an object of type CoordinateRepr{Symbol}. Each site is mapped to a symbol, different symbols mean different domains\ndomain_mapping: domain mapping matrix. Each site is mapped to a symbol, different symbols mean different domains\nrepr_spec: representation specifier for the domain_mapping (see CoordinateRepr docs for more information)\n\n\n\n\n\n","category":"function"},{"location":"scope/#TopologicalMarkers.@landau","page":"Library","title":"TopologicalMarkers.@landau","text":"@landau(B)\n\nGenerates a function that returns the Landau gauge vector potential. This can be used as an argument for the field! function.\n\nArguments\n\nB: the magnetic field value\n\n\n\n\n\n","category":"macro"},{"location":"scope/#TopologicalMarkers.@symm","page":"Library","title":"TopologicalMarkers.@symm","text":"@symm(B[, center])\n\nGenerates a function that returns the symmetric gauge vector potential. This can be used as an argument for the field! function.\n\nArguments\n\nB: the value of magnetic field\ncenter: the center of symmetry of the vector potential\n\n\n\n\n\n","category":"macro"},{"location":"scope/#TopologicalMarkers.@flux","page":"Library","title":"TopologicalMarkers.@flux","text":"flux(Φ[, point])\n\nGenerates a function that returns the vector potential for a flux quantum. This can be used as an argument for the field! function.\n\nArguments\n\nΦ: the value of magnetic field\npoint: the point where the flux is located\n\n\n\n\n\n","category":"macro"},{"location":"scope/#Other-linear-operators","page":"Library","title":"Other linear operators","text":"","category":"section"},{"location":"scope/","page":"Library","title":"Library","text":"coord_operators\nfilled_projector\ncurrents","category":"page"},{"location":"scope/#TopologicalMarkers.coord_operators","page":"Library","title":"TopologicalMarkers.coord_operators","text":"coord_operators([lattice_size]; symmetric = true)\n\nReturns a tuple of coordinate operators (i. e. hatX and hatY).\n\nArguments\n\nlattice_size: the size of the lattice\n\nKeyword arguments\n\nsymmetric: true if the operator is symmetrically defined (in other words, the central site of the lattice corresponds to (0, 0)), false otherwise. True by default\n\n\n\n\n\n","category":"function"},{"location":"scope/#TopologicalMarkers.filled_projector","page":"Library","title":"TopologicalMarkers.filled_projector","text":"filled_projector(H[, fermi_energy = 0, T = 0])\n\nReturns a projector onto the filled states (in other words - a density matrix of the ground state). If T is non-zero, the state density will correspond to the Fermi-Dirac distribution.\n\nArguments\n\nH: the hamiltonian matrix\nfermi_energy: the Fermi energy level\nT: temperature of the system\n\n\n\n\n\n","category":"function"},{"location":"scope/#TopologicalMarkers.currents","page":"Library","title":"TopologicalMarkers.currents","text":"currents(H, P[, lattice_size])\n\nReturns a skew-symmetric matrix of electric currents between sites.\n\nArguments\n\nH: the hamiltonian matrix\nP: the density matrix\nlattice_size: the size of the lattice the hamiltonian is defined for\n\n\n\n\n\n","category":"function"},{"location":"scope/#bianca_resta_currents","page":"Library","title":"Bianca-Resta currents","text":"","category":"section"},{"location":"scope/","page":"Library","title":"Library","text":"Modules = [TopologicalMarkers]\nPages = [joinpath(\"formulas\", \"lcm_currents.jl\")]","category":"page"},{"location":"scope/#TopologicalMarkers.@J_b-NTuple{4, Any}","page":"Library","title":"TopologicalMarkers.@J_b","text":"@J_b(H, P, X, Y)\n\nCalculates the sum of @J_c and @J_m currents.\n\n\n\n\n\n","category":"macro"},{"location":"scope/#TopologicalMarkers.@J_c-NTuple{4, Any}","page":"Library","title":"TopologicalMarkers.@J_c","text":"@J_c(H, P, X, Y)\n\nCalculates the Bianca-Resta current part using the following formula:\n\nJ_c(r r) =  4pi ( \nlangle r  PXPYP  r rangle langle r  H  r rangle -\nlangle r  H  r rangle langle r  PXPYP  r rangle\n)\n\n\n\n\n\n","category":"macro"},{"location":"scope/#TopologicalMarkers.@J_eq-NTuple{4, Any}","page":"Library","title":"TopologicalMarkers.@J_eq","text":"@J_eq(H, P, X, Y)\n\nCalculates the Bianca-Resta current using the following formula:\n\nJ_eq(r r) =  4pi ( \nlangle r  PHXP  r rangle langle r  PYP  r rangle -\nlangle r  PYP  r rangle langle r  PHXP  r rangle  -\nlangle r  PHYP  r rangle langle r  PXP  r rangle +\nlangle r  PXP  r rangle langle r  PHYP  r rangle\n)\n\n\n\n\n\n","category":"macro"},{"location":"scope/#TopologicalMarkers.@J_inv-NTuple{4, Any}","page":"Library","title":"TopologicalMarkers.@J_inv","text":"@J_inv(H, P, X, Y)\n\nCalculates the sum of @J_c and @J_m_inv currents.\n\n\n\n\n\n","category":"macro"},{"location":"scope/#TopologicalMarkers.@J_m-NTuple{4, Any}","page":"Library","title":"TopologicalMarkers.@J_m","text":"@J_m(H, P, X, Y)\n\nCalculates the Bianca-Resta current part using the following formula:\n\nJ_m(r r) =  4pi ( \nlangle r  PHXP  r rangle langle r  PYP  r rangle -\nlangle r  PYP  r rangle langle r  PHXP  r rangle  -\nlangle r  PHYP  r rangle langle r  PXP  r rangle +\nlangle r  PXP  r rangle langle r  PHYP  r rangle\n)\n\n\n\n\n\n","category":"macro"},{"location":"scope/#TopologicalMarkers.@J_m_tr-NTuple{4, Any}","page":"Library","title":"TopologicalMarkers.@J_m_tr","text":"@J_m_tr(H, P, X, Y)\n\nCalculates the Bianca-Resta current part using the following formula:\n\nJ_m_tr(r r) =  4pi ( \nlangle r  P  r rangle langle r  HX PYP  r rangle -\nlangle r  HX PYP  r rangle langle r  P  r rangle  -\nlangle r  PYP  r rangle langle r  HX P  r rangle +\nlangle r  HX P  r rangle langle r  PYP  r rangle  -\nlangle r  P  r rangle langle r  HY PXP  r rangle +\nlangle r  HY PXP  r rangle langle r  P  r rangle  +\nlangle r  PXP  r rangle langle r  HY P  r rangle -\nlangle r  HY P  r rangle langle r  PXP  r rangle\n)\n\n\n\n\n\n","category":"macro"},{"location":"scope/#TopologicalMarkers.@J_treq-NTuple{4, Any}","page":"Library","title":"TopologicalMarkers.@J_treq","text":"@J_treq(H, P, X, Y)\n\nCalculates the Bianca-Resta current using the following formula:\n\nJ_treq(r r) =  4pi ( \nlangle r  HP P  r rangle langle r  PXPYP  r rangle -\nlangle r  PXPYP  r rangle langle r  HP P  r rangle  -\nlangle r  HP P  r rangle langle r  PYPXP  r rangle +\nlangle r  PYPXP  r rangle langle r  HP P  r rangle  +\nlangle r  P  r rangle langle r  HP XPYP  r rangle -\nlangle r  HP XPYP  r rangle langle r  P  r rangle  +\nlangle r  P HP XP  r rangle langle r  PYP  r rangle -\nlangle r  PYP  r rangle langle r  P HP XP  r rangle  -\nlangle r  P  r rangle langle r  HP YPXP  r rangle +\nlangle r  HP YPXP  r rangle langle r  P  r rangle  -\nlangle r  P HP YP  r rangle langle r  PXP  r rangle +\nlangle r  PXP  r rangle langle r  P HP YP  r rangle\n)\n\n\n\n\n\n","category":"macro"},{"location":"scope/#TopologicalMarkers.@currents-Tuple{Any}","page":"Library","title":"TopologicalMarkers.@currents","text":"@currents(currents_lambda)\n\nGenerates a matrix with currents, given a lambda/macro call that takes lattice site indices and returns the current value.\n\nExample usage:\n\ncurrents_mat = @currents @J_b H P X Y\n\n\n\n\n\n","category":"macro"},{"location":"scope/#Unitary-evolution","page":"Library","title":"Unitary evolution","text":"","category":"section"},{"location":"scope/","page":"Library","title":"Library","text":"evolution_operator\n@evolution","category":"page"},{"location":"scope/#TopologicalMarkers.evolution_operator","page":"Library","title":"TopologicalMarkers.evolution_operator","text":"evolution_operator(H, t)\n\nCalculates the unitary evolution operator using the formula\n\n$ \\mathcal{U}(t) = e^{-\\frac{1}{i\\hbar} \\hat{H} t} $\n\nArguments\n\nH: the hamiltonian matrix\nt: the evolution time\n\n\n\n\n\n","category":"function"},{"location":"scope/#TopologicalMarkers.@evolution","page":"Library","title":"TopologicalMarkers.@evolution","text":"@evolution [rules...] for_loop\n\nGenerates an environment with defined hamiltonian and density matrices that evolve by certain laws. See Unitary evolution for more details.\n\n\n\n\n\n","category":"macro"},{"location":"scope/#Data-visualization","page":"Library","title":"Data visualization","text":"","category":"section"},{"location":"scope/","page":"Library","title":"Library","text":"CoordinateRepr\nheatmap_data\nquiver_data","category":"page"},{"location":"scope/#TopologicalMarkers.CoordinateRepr","page":"Library","title":"TopologicalMarkers.CoordinateRepr","text":"CoordinateRepr{T}\n\nA wrapper struct for matrices to be conveniently plotted.\n\nArguments\n\nlattice: A matrix representing some quantity defined on the lattice (e. g. the LCM)\nrepr_spec: A symbol defining the way how the lattice sites match the matrix values:\n:c or :coord: The value for (x, y) site is A[x, y]. This is the default value\n:n of :natural: If you print out the matrix as you usually do, and then imagine\na coordinate system with its center in the bottom-left corner, this will be the mapping between   sites and matrix values\n\n\n\n\n\n","category":"type"},{"location":"scope/#TopologicalMarkers.heatmap_data","page":"Library","title":"TopologicalMarkers.heatmap_data","text":"heatmap_data(op[, lattice_size])\n\nGenerates a CoordinateRepr for coordinate representation traces: langle r  hatmathcalO  r rangle.\n\nArguments\n\nop: the operator to find values for\nlattice_size: the size of the lattice\n\n\n\n\n\n","category":"function"},{"location":"scope/#TopologicalMarkers.quiver_data","page":"Library","title":"TopologicalMarkers.quiver_data","text":"quiver_data(currents_mat[, lattice_size]; <keyword arguments>)\n\nGenerates data for a quiver plot using a matrix with currents. The output is a tuple of two vectors with equal length: one contains arrow origins, the other one - arrow vectors.\n\nArguments\n\ncurrents_mat: a matrix with currents\nlattice_size: the size of the lattice\n\nKeyword arguments\n\nthreshold: minimum value of the current to be put to output. Default is 0.1\ndist_threshold: maximum distance between sites for which the current will be evaluated. Infinite by default\nxlims and ylims: limit the area in which the currents will be evaluated. Infinite by default\n\n\n\n\n\n","category":"function"},{"location":"scope/#Plotting-shorthands","page":"Library","title":"Plotting shorthands","text":"","category":"section"},{"location":"scope/","page":"Library","title":"Library","text":"These functions may come in handy when you want to plot many heatmaps and electric current diagrams in one line.","category":"page"},{"location":"scope/","page":"Library","title":"Library","text":"plot_boundaries!\nplot_figure!\noptimal_layout\nplot_auto","category":"page"},{"location":"scope/#TopologicalMarkers.plot_boundaries!","page":"Library","title":"TopologicalMarkers.plot_boundaries!","text":"plot_boundaries!([pl, ]domain_mapping; <keyword arguments>)\n\nDraws boundaries between different domains described by the domain_mapping matrix.\n\nArguments\n\npl: a Plots.Plot object to visualize data on\ndomain_mapping: a CoordinateRepr object that represents domain mapping. The boundaries between different domains will be drawn\n\nAll keyword arguments will be passed to the plot! function used for drawing - this can be used to change the line thickness or style, for example.\n\n\n\n\n\n","category":"function"},{"location":"scope/#TopologicalMarkers.plot_figure!","page":"Library","title":"TopologicalMarkers.plot_figure!","text":"plot_figure!(pl; <keyword arguments>)\n\nPlots complicated splitline data series (heatmap, boundaries, quiver) on a single figure.\n\nArguments\n\npl: a Plots.Plot object to visualize data on\n\nKeyword arguments\n\nhmap: data to be visualized on a heatmap. It can be a CoordinateRepr object (then it will be plotted directly)\n\nor a linear operator matrix (then the CoordinateRepr will be generated automatically)\n\ndomain_mapping: a CoordinateRepr object that represents domain mapping. The boundaries between different domains will be drawn.\ncurrents: a matrix containing currents between sites\nxlims and ylims: objects of type Tuple{Int, Int} that define the limits of the x- and y- axes respectively\n\nAll other keyword arguments with the following prefixes are passed to the plot! function:\n\nhmap for the heatmap\nbounds for the boundaries\ncurrents for the quiver\n\nThis can be used to style the plot. For example, this line will result in the domain boundaries being drawn in dot style, the limits of the heatmap will be set from -3 to 3, and the arrows depicting the currents will be blue:\n\nplot_figure!(..., hmapclims=(-3, 3), boundsstyle=:dot, :currentscolor=:green)\n\n\n\n\n\n","category":"function"},{"location":"scope/#TopologicalMarkers.optimal_layout","page":"Library","title":"TopologicalMarkers.optimal_layout","text":"optimal_layout(figures_total; <keyword arguments>)\n\nGenerates optimal layout for multiple figures in a plot.\n\nArguments\n\nfigures_total: the number of figures to place on the plot\n\nKeyword arguments\n\nplot_aspect_ratio: The aspect ratio of the plot. 1:1 bu default\nfigure_aspect_ratio: the aspect ratio of one figure of the plot. 7:5 by default\n\n\n\n\n\n","category":"function"},{"location":"scope/#TopologicalMarkers.plot_auto","page":"Library","title":"TopologicalMarkers.plot_auto","text":"plot_auto(<arguments>; <keyword arguments>)\n\nPlots multiple heatmaps, cutaway views or currents simultaneously.\n\nThe subplots are automatically arranged into an optimal layout.\n\nArguments\n\nEach argument can be either a CoordinateRepr object or a chain of pairs.\n\nKeyword arguments\n\nlayout: a Plots.Layout object to use. If not specified, an optimal layout will be\n\ngenerated depending on the plot size.\n\nplot_size: actual size of the plot. If not specified, then the layout parameter will\n\nbe ignored and the size will be optimal for the layout\n\ntitle: the title of the graph\ncutaway_view: Tuple that indicates which cutaway view should be\n\ndrawn on a separate figure\n\ncutaway_views: Same as previous, but many of them\n\nAll other keyword arguments with the following prefixes are passed to the plot! function:\n\nhmap for the heatmap\nbounds for the boundaries\ncurrents for the quiver\ncutaway for the cutaway figure\nsplitline for the line on all figures that shows the plane of the cutaway views\n\n\n\n\n\n","category":"function"},{"location":"evolution/#unitary_evolution","page":"Unitary evolution","title":"Unitary evolution","text":"","category":"section"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Suppose we want to study the behavior of some quantum system in time-dependent conditions. We can use the unitary evolution operator to describe how the density matrix depends on time:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"mathcalU(t) = Tleft e^frac1ihbar int_t_0^t hatH(tau) dtau righthspace05cm\nmathcalP(t) = mathcalU(t) mathcalP_0 mathcalU^dagger (t)","category":"page"},{"location":"evolution/#The-static-evolution-function","page":"Unitary evolution","title":"The static evolution function","text":"","category":"section"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"The evolution_operator function calculates the evolution operator for a time-independent hamiltonian.  Its input parameters are the hamiltonian matrix H and the time interval t.","category":"page"},{"location":"evolution/#Matrix-exponent-optimization","page":"Unitary evolution","title":"Matrix exponent optimization","text":"","category":"section"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"The matrix exponent is the heaviest linear algebra operation used in this project.  To speed up calculations in some times, you can set up the matrix exponent to be calculated in a simpler way with this function:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"TopologicalMarkers._configure_evolution!(simplify::Bool; <keyword arguments...>)","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"If the simplify parameter is set to to true, the matrix exponent is evaluated using the Taylor series. You can set other parameters with following keywords:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"order: The quantity of members of the Taylor expansion to be calculated\nthreshold: To avoid precision loss, if the t parameter is greater than threshold, the exponent will be evaluated using the exp function. Set to nothing to always use Taylor expansion.","category":"page"},{"location":"evolution/#The-evolution-macro","page":"Unitary evolution","title":"The evolution macro","text":"","category":"section"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"This macro can be quite useful if your hamiltonian depends on time or if there are multiple hamiltonians in your experiment. Let us define a function that takes the time and returns the hamiltonian:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"h(t) = hamiltonian(ms, field = @symm(Bf * min(t, τ) / τ))","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Here h(t) describes the magnetic field being adiabatically turned on.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Take a look at the example 2 from the Home/Examples section. The @evolution macro creates a block where the hamiltonian and density matrices are evaluated for the given time interval.  It takes two arguments - a list/vector with evolution specifiers and a for-loop that iterates over the time interval:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"a = Animation()\n\n@evolution [\n    :ham => h => H,\n    P0 => h => P\n] for time in time_domain\n    cur = currents(H, P)\n    plot_auto(\"Local density\" => P => cur * 40, hmapclims = (0.98, 1.02))\n    frame(a)\nend","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Let us make it clear what an evolution specifier is: it is a pair chain with three arguments:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"arg1 => arg2 => arg3","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"There are two options what these arguments can be:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"The first argument is a density matrix at the moment t = 0. The second is the function describing the hamiltonian time dependence, and the third one is the name for the density matrix at the t = texttime moment - a variable with such a name will be defined inside the loop body.\nThe first argument is the :ham symbol. Then the second one is still the hamiltonian function, and the third one is the name for the hamiltonian matrix at the t = texttime moment.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"So, in the example before in the for-loop body H stands for h(time), and P is the evolved P0 density matrix.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"note: Note\nIt is important that arg2 must be a function name - therefore you cannot use a lambda expression in such context.  This is done with purpose to make the resulting code more readable.Note that if the hamiltonian matrix does not depend on time, you still need to define a function.  The reason is that it is nearly impossible to detect if it is a function name or a variable name at compile-time.","category":"page"},{"location":"evolution/#Performance","page":"Unitary evolution","title":"Performance","text":"","category":"section"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"To speed up calculations, one might use libraries such as CUDA.jl that provide an alternative linear algebra interface.  To make them compatible with the @evolution macro, you should define these operatots and functions for the new matrix type:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Equality operator: ==\nBasic arithmetic functions: +, -, *, adjoint\nThe matrix exponent exp(A)\nIf it is not possible to implement this function (like in CUDA.jl), you can define the one(A) function which returns the identity matrix with the size same as A. \nThen you need to configure the evolution operator function to enable the Taylor expansion formula","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"!!! Tip     The hamiltonian function is slow enough - this is the price we have to pay for its flexibility.     The most time-consuming tasks are allocating a new matrix and calling lambda-functions to evaluate the Peierls substitution.     Avoid calling it when evaluating the h(t) for the evolution operator when possible.","category":"page"},{"location":"#TopologicalMarkers.jl","page":"Home","title":"TopologicalMarkers.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A package that simplifies calculation of different topological markers.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install it, simply copy this line to julia's REPL and execute it:","category":"page"},{"location":"","page":"Home","title":"Home","text":"]add https://github.com/aryavorskiy/TopologicalMarkers/","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"#Different-local-markers-in-an-equilibrium","page":"Home","title":"Different local markers in an equilibrium","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let us take a Chern insulator, set the m parameter to -1 in the middle of the lattice and 1 everywhere else, and then evaluate the local Chern marker using both Bianca-Resta and Streda formulas (i. e. the linear response of the local density to the magnetic field):","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TopologicalMarkers\nusing Plots\n\n# Set the m parameter to -1 on the whole lattice\n# Let the phase be topological\nm_lattice = ones(25, 25)\nm_lattice[11:15, 11:15] .= -1\nH = hamiltonian(m_lattice, :c)\n\nP = filled_projector(H)             # Ground state density matrix\nX, Y = coord_operators()            # Coordinate operator matrices\nch = -4π * im * P * X * P * Y * P   # Bianca-Resta local Chern operator\n\n# Calculate the perturbation of the density matrix\nB = 0.01\nHb = hamiltonian(m_lattice, :c, field = @landau(B))\nPb = filled_projector(Hb)\nstr = (Pb - P) / B\n\n# Finally, plot everything\nplot_auto(\"Bianca-Resta\" => ch, \"Streda\" => str, plot_size = (800, 600),\n    hmapclims = (-1.5, 1.5), currentscolor = :yellow, cutaway_view = (13, 13), \n    markercolor = :brown)","category":"page"},{"location":"","page":"Home","title":"Home","text":"See Hamiltonian generation and Visualization for detailed explanation.","category":"page"},{"location":"#Adiabatic-flux-quantum-application","page":"Home","title":"Adiabatic flux quantum application","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To understand better how the particle density and electric currents react to adiabatic flux quantum appearance, let us create an animation of it. The Chern insulator is in topological phase, with m = 1.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TopologicalMarkers\nusing Plots\n\n# Set the m parameter to 1 on the whole lattice\n# Let the phase be topological again\nms = CoordinateRepr(ones(15, 15))\nBf = 0.01\nτ = 30\ntime_domain = 0:0.5:τ\n\n# Define how the hamiltonian depends on time\nH0 = hamiltonian(ms)\nP0 = filled_projector(H0)\nh(t) = hamiltonian(ms, field = @flux(Bf * t / τ))   # This is a function definition\n\na = Animation()\n\n# The code in the square brackets defines `H` and `P` variables in the loop body\n# The comma can be omitted\n@evolution [\n    :ham => h => H,\n    P0 => h => P\n] for t in time_domain\n    cur = currents(H, P)\n    plot_auto(\"Local density\" => P => 100cur, plot_size = (800, 600), hmapclims = (0.9, 1.1))\n    frame(a)\nend\n\n# Export the animation\ngif(a, \"example_animation.gif\", fps = 10)","category":"page"},{"location":"","page":"Home","title":"Home","text":"See Unitary evolution for detailed explanation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"tip: Tip\nThere are more examples of different use cases in this notebook: github.com/aryavorskiy/TopologicalMarkers.jl/supplementary.ipynb All pictures from the article were created using this notebook.","category":"page"}]
}
